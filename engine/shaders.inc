static const char* fixedpipe_vert = {
    "// CAUTION: never use 'int' attributes. They don't work for reasons unknown to me.\n"
    "// There doesn't seem to be a good way to query the uniforms in use for OpenGL 3.1. Very annoying.\n"
    "// EL_MAX_INSTANCE = 16\n"
    "// EL_MAX_BONES = 12\n"
    "// \n"
    "//	mvpMatrix		4			4\n"
    "// 	mMatrix		4*16		64\n"
    "//	paramArr		1*16		16\n"
    "//	colorMult		1			1\n"
    "//	boneXForm	12*16	192		// technically vec3, but doubt it packs\n"
    "//	normalMat		4			4\n"
    "// 	lighting			3			3\n"
    "//\n"
    "//									284 plus overhead\n"
    "// If needed, can possibly pack boneXForm into 4*16 = 64, bringing it down to 156, which is huge in getting it under 256, for systems with that limit. \n"
    "uniform mat4 	u_mvpMatrix;		// model-view-projection.\n"
    "									// although the model is identity in the instancing case.\n"
    "#if INSTANCE == 1\n"
    "	uniform mat4 	u_mMatrix[EL_MAX_INSTANCE];		// Each instance gets its own transform. Burns up uniforms; this can't be huge.\n"
    "	#if PARAM == 1\n"
    "		uniform vec4	u_paramArr[EL_MAX_INSTANCE];	// Arbitrary params, if used. (texture xform, color, etc.)\n"
    "	#endif\n"
    "	attribute float a_instanceID;					// Index into the transformation.\n"
    "#else\n"
    "	#if PARAM == 1\n"
    "		uniform vec4	u_param;					// Arbitrary params, if used. (texture xform, color, etc.)\n"
    "	#endif\n"
    "#endif\n"
    "#if COLOR_MULTIPLIER == 1\n"
    "	uniform vec4 u_colorMult;		// Overall Color, if specified.\n"
    "#endif\n"
    "attribute vec3 a_pos;				// vertex position\n"
    "#if COLORS == 1\n"
    "	attribute vec4 a_color;			// vertex color\n"
    "#endif\n"
    "#if TEXTURE0 == 1\n"
    "	attribute vec2 a_uv0;\n"
    "	varying vec2 v_uv0;\n"
    "#endif\n"
    "#if TEXTURE1 == 1\n"
    "	attribute vec2 a_uv1;\n"
    "	varying vec2 v_uv1;\n"
    "#endif\n"
    "#if BONES == 1\n"
    "	attribute float a_boneID;\n"
    "	#if INSTANCE == 1\n"
    "		// FIXME: Can (and should) pack into floats and use a scaling term. Currently: xform.x:rotation, xform.y:y, xform.z:z\n"
    "		uniform vec3 u_boneXForm[EL_MAX_BONES*EL_MAX_INSTANCE];\n"
    "	#else\n"
    "		uniform vec3 u_boneXForm[EL_MAX_BONES];	\n"
    "	#endif\n"
    "#endif\n"
    "#if LIGHTING_DIFFUSE > 0\n"
    "	uniform mat4 u_normalMatrix;	// normal transformation\n"
    "	uniform vec3 u_lightDir;		// light direction, eye space (x,y,z,0)\n"
    "	uniform vec4 u_ambient;			// ambient light. ambient+diffuse = 1\n"
    "	uniform vec4 u_diffuse;			// diffuse light\n"
    "	attribute vec3 a_normal;		// vertex normal\n"
    "#endif\n"
    "varying vec4 v_color;\n"
    "void main() {\n"
    "	#if PARAM == 1\n"
    "		// Don't go insane with #if syntax later:\n"
    "		#if INSTANCE == 1\n"
    "			vec4 param = u_paramArr[int(a_instanceID)];\n"
    "		#else\n"
    "			vec4 param = u_param;\n"
    "		#endif\n"
    "	#endif\n"
    "	#if COLOR_MULTIPLIER == 0\n"
    "		vec4 color = vec4( 1,1,1,1 );\n"
    "	#elif COLOR_MULTIPLIER == 1\n"
    "		vec4 color = u_colorMult;\n"
    "	#endif\n"
    "	\n"
    "	#if COLOR_PARAM == 1\n"
    "		color *= param;\n"
    "	#endif\n"
    "	\n"
    "	#if COLORS == 1\n"
    "		color *= a_color;\n"
    "	#endif\n"
    "	#if TEXTURE0 == 1\n"
    "		#if TEXTURE0_TRANSFORM == 1\n"
    "			v_uv0 = vec2( a_uv0.x*param.x + param.z, a_uv0.y*param.y + param.w );\n"
    "		#else\n"
    "			v_uv0 = a_uv0;\n"
    "		#endif\n"
    "	#endif\n"
    "	#if TEXTURE1 == 1\n"
    "		#if TEXTURE1_TRANSFORM == 1\n"
    "			v_uv1 = vec2( a_uv1.x*param.x + param.z, a_uv1.y*param.y + param.w );\n"
    "		#else\n"
    "			v_uv1 = a_uv1;\n"
    "		#endif\n"
    "	#endif\n"
    "	mat4 xform = mat4( 1.0 );	\n"
    "	#if BONES == 1\n"
    "		#if INSTANCE == 1\n"
    "		vec3 bone = u_boneXForm[int(a_boneID + a_instanceID*float(EL_MAX_BONES))];\n"
    "		#else\n"
    "		vec3 bone = u_boneXForm[int(a_boneID)];\n"
    "		#endif\n"
    "		float sinTheta = sin( bone.x );\n"
    "		float cosTheta = cos( bone.x );\n"
    "		/*\n"
    "			// COLUMN 1\n"
    "			x[0] = 1.0f;\n"
    "			x[1] = 0.0f;\n"
    "			x[2] = 0.0f;\n"
    "			\n"
    "			// COLUMN 2\n"
    "			x[4] = 0.0f;\n"
    "			x[5] = cosTheta;\n"
    "			x[6] = sinTheta;\n"
    "			// COLUMN 3\n"
    "			x[8] = 0.0f;\n"
    "			x[9] = -sinTheta;\n"
    "			x[10] = cosTheta;\n"
    "		*/			\n"
    "		// column, row (grr)\n"
    "		xform[1][1] = cosTheta;\n"
    "		xform[1][2] = sinTheta;\n"
    "		xform[2][1] = -sinTheta;\n"
    "		xform[2][2] = cosTheta;\n"
    "		\n"
    "		xform[3][1] = bone.y;\n"
    "		xform[3][2] = bone.z;\n"
    "	#endif\n"
    "	\n"
    "	#if INSTANCE == 0 \n"
    "		#if BONES == 0\n"
    "			vec4 pos = u_mvpMatrix * vec4( a_pos.x, a_pos.y, a_pos.z, 1.0 );\n"
    "		#else\n"
    "			vec4 pos = u_mvpMatrix * xform * vec4( a_pos.x, a_pos.y, a_pos.z, 1.0 );\n"
    "		#endif\n"
    "	#else\n"
    "		#if BONES == 0\n"
    "			vec4 pos = (u_mvpMatrix * u_mMatrix[int(a_instanceID)]) * vec4( a_pos.x, a_pos.y, a_pos.z, 1.0 );\n"
    "		#else\n"
    "			vec4 pos = (u_mvpMatrix * u_mMatrix[int(a_instanceID)]) * xform * vec4( a_pos.x, a_pos.y, a_pos.z, 1.0 );\n"
    "		#endif\n"
    "	#endif\n"
    "	\n"
    "	#if LIGHTING_DIFFUSE  > 0\n"
    "		#if INSTANCE == 0 \n"
    "			vec3 normal = normalize( ( u_normalMatrix  * xform * vec4( a_normal.x, a_normal.y, a_normal.z, 0 ) ).xyz );\n"
    "		#else\n"
    "			vec3 normal = normalize( (( u_normalMatrix  * xform * u_mMatrix[int(a_instanceID)]) * vec4( a_normal.x, a_normal.y, a_normal.z, 0 ) ).xyz );\n"
    "		#endif\n"
    "		#if LIGHTING_DIFFUSE == 1\n"
    "			// Lambert lighting with ambient term.\n"
    "			// fixme: not clear we need to normalize\n"
    "			float nDotL = max( dot( normal, u_lightDir ), 0.0 );\n"
    "			vec4 light = u_ambient + u_diffuse * nDotL;\n"
    "		#elif LIGHTING_DIFFUSE == 2\n"
    "			// Hemispherical lighting. The 'u_diffuse' is used for the main light,\n"
    "			// and 'u_ambient' for the key light, just so as not to introduce new variables.\n"
    "			// fixme: not clear we need to normalize\n"
    "			float nDotL = dot( normal, u_lightDir );\n"
    "			vec4 light = mix( u_ambient, u_diffuse, (nDotL + 1.0)*0.5 );\n"
    "		#else	\n"
    "			#error light not defined\n"
    "		#endif\n"
    "		color *= light;\n"
    "	#endif\n"
    "	\n"
    "	#if BONE_FILTER == 1\n"
    "		float mult = ( param.x == a_boneID ) ? 1.0 : 0.0; \n"
    "		pos = pos * mult;\n"
    "	#endif\n"
    "	\n"
    "	gl_Position = pos;\n"
    "	v_color = color;\n"
    "}\n"
};
static const char* fixedpipe_frag = {
    "#if TEXTURE0 == 1\n"
    "	uniform sampler2D texture0;\n"
    "	varying vec2 v_uv0;\n"
    "#endif\n"
    "#if TEXTURE1 == 1\n"
    "	uniform sampler2D texture1;\n"
    "	varying vec2 v_uv1;\n"
    "#endif\n"
    "varying vec4 v_color;\n"
    "void main() \n"
    "{\n"
    "	vec4 color = v_color;\n"
    "	#if TEXTURE0 == 1\n"
    "		#if TEXTURE0_ALPHA_ONLY == 1\n"
    "			color.a *= texture2D( texture0, v_uv0).a;\n"
    "		#elif EMISSIVE == 1\n"
    "			// Basically, the alpha color is used to\n"
    "			// modulate the incoming fragment color, which\n"
    "			// is the result of lighting.\n"
    "			vec4 texColor = texture2D( texture0, v_uv0 );\n"
    "			#if EMISSIVE_EXCLUSIVE == 0\n"
    "				// In 'normal'emissive mode, the incoming color (lighting)\n"
    "				// is mixed out as the emissiveness increases.\n"
    "				color = mix( color, vec4(1,1,1,1), texColor.a ) * texColor;\n"
    "			#elif EMISSIVE_EXCLUSIVE == 1\n"
    "				// In 'exclusive' mode, everything is black, and mixed\n"
    "				// to the emmissive color.\n"
    "				color = mix( vec4(0,0,0,1), texColor, texColor.a );\n"
    "			#endif\n"
    "		#else\n"
    "			color *= texture2D( texture0, v_uv0 );\n"
    "		#endif\n"
    "	#endif\n"
    "	#if TEXTURE1 == 1\n"
    "		#if TEXTURE1_ALPHA_ONLY == 1\n"
    "			color.a *= texture2D( texture1, v_uv1).a;\n"
    "		#else\n"
    "			color *= texture2D( texture1, v_uv1 );\n"
    "		#endif\n"
    "	#endif\n"
    "	#if PREMULT == 1\n"
    "		color = vec4( color.r*color.a, color.g*color.a, color.b*color.a, color.a );\n"
    "	#endif\n"
    "	gl_FragColor = color;\n"
    "}\n"
};
