/*
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef UFO_ATTACK_TEXTURE_INCLUDED
#define UFO_ATTACK_TEXTURE_INCLUDED

#include "../grinliz/gldebug.h"
#include "../grinliz/gltypes.h"
#include "../grinliz/glstringutil.h"
#include "../grinliz/glcontainer.h"
#include "../shared/gamedbreader.h"
#include "../engine/ufoutil.h"

class Surface;
class Texture;
struct GPUMem;

class ITextureCreator
{
public:
	virtual void CreateTexture( Texture* t ) = 0;
};


class Texture
{
	friend class TextureManager;
	friend class RenderTarget;
public:
	enum { MAX_TEXTURE_NAME = 24 };

	// WARNING: duplicated in Surface
	enum  {			// channels	bytes
		RGBA16,		// 4444		2
		RGB16,		// 565		2
		ALPHA,		// 8		1
	};

	enum {
		PARAM_NONE		= 0,
		PARAM_NEAREST	= 0x01,
		PARAM_LINEAR	= 0x02,
		PARAM_EMISSIVE	= 0x04,
		PARAM_SOFTWARE_MIP = 0x08,	// work around driver bug.
	};

	Texture()					{ creator = 0; } 

	const char* Name() const	{ return name.c_str(); }
	// Is there an alpha channel? (Emissive or transparent.)
	bool Alpha() const			{ return (format != RGB16); };
	// Is the alpha channel emissive?
	bool Emissive() const		{ return (flags & PARAM_EMISSIVE) != 0; }

	float AspectRatio() const	{ return (float)w / (float)h; }

	int Format() const			{ return format; }
	int Flags() const			{ return flags; }
	int Width() const			{ return w; }
	int Height() const			{ return h; }

	void Upload( const void* mem, int size );
	void Upload( const Surface& surface );
	bool Empty() const			{ return creator == 0 && item == 0 && glID == 0 && name.empty(); }

	int BytesInImage() const	{ return w*h*BytesPerPixel(); }
	int BytesPerPixel() const	{ return (format == ALPHA) ? 1 : 2; }

	U32 GLID();

	void SetEmissive( bool on )	{ if ( on ) 
									flags |= PARAM_EMISSIVE;
								  else
									flags &= (~PARAM_EMISSIVE);
								}
	void SetSoftwareMip( bool on )	{	if ( on )
											flags |= PARAM_SOFTWARE_MIP;
										else
											flags &= (~PARAM_SOFTWARE_MIP);
										}
	struct TableEntry {
		grinliz::IString	name;
		grinliz::Vector4F	uv;
		grinliz::Vector4F	clip;

		grinliz::Vector4F	uvXForm;		// a,d,tx,ty
	};
	int NumTableEntries() const;
	void GetTableEntry( int i, TableEntry* te ) const;
	void GetTableEntry( const char* name, TableEntry* te ) const;

private:
	void GetTE( const gamedb::Item* item, TableEntry* te ) const;
	void Set( const char* name, int w, int h, int format, int flags );

	grinliz::CStr< MAX_TEXTURE_NAME > name;
	int w, h, format;
	int flags;

	ITextureCreator* creator;			// if generated by the host
	const gamedb::Item* item;			// if attached to the database

	U32 glID;
};


class TextureManager
{
	friend class Texture;
public:
	static TextureManager* Instance()	{ GLASSERT( instance ); return instance; }

	void DeviceLoss();
	void Reload();

	bool IsTexture( const char* name );
	Texture* GetTexture( const char* name, bool reload=false );
	Texture* CreateTexture( const char* name, int w, int h, int format, 
							int flags = 0, 
							ITextureCreator* create = 0 );
	void ContextShift();
	void TextureCreatorInvalid( ITextureCreator* create );

	unsigned NumTextures() const			{ return textureArr.Size(); }
	U32 CalcTextureMem() const;

	static void Create( const gamedb::Reader* );
	static void Destroy();

private:
	TextureManager( const gamedb::Reader* );
	~TextureManager();

	// called by the texture
	void CalcOpenGL( int format, int* glFormat, int* glType );
	U32 CreateGLTexture( int w, int h, int format, int flags );

	enum {
		MAX_TEXTURES = 100		// increase as needed
	};

	static TextureManager* instance;
	const gamedb::Reader* database;

	int cacheMiss;
	int cacheHit;
	int cacheReuse;
	int emptySpace;

	grinliz::CArray< Texture, MAX_TEXTURES > textureArr;	// textures
	grinliz::HashTable<	const char*, Texture*, grinliz::CompCharPtr >	texMap;
};

#endif // UFO_ATTACK_TEXTURE_INCLUDED
